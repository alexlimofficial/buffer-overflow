# 32-Bit Intel Buffer Overflow Vulnerability

A proof-of-concept buffer overflow vulnerability is explored in this repository. This project provides a step-through tutorial on obtaining root shell privileges through buffer overflow attacks. 

## Getting Started

The environment used in this project was a Linux virtual machine (Ubuntu 16.04 LTS) running on VirtualBox.

1. 32-Bit Ubuntu 16.04 LTS [download](https://www.ubuntu.com/download/desktop)
2. VirtualBox [download](https://www.virtualbox.org/wiki/Downloads)


## Preparing The Machine

Modern-day machines are equipped with several protection schemes that aim to prevent buffer overflow attacks. It is necessary to disable those protection schemes in order to observe a successful buffer overflow attack.

### Address-Space Layout Randomization (ASLR)

ASLR is computer security technique that provides protection against memory exploitation vulnerabilities. It works by rearranging the address space positions of key data areas of a process, including the base of the executable and the positions of the data segment features (stack, heap, etc.). By having this protection, it is much more difficult for a hacker to guess the exact address to target (e.g. starting address of their malicious code). 

In Ubuntu, this protection was disabled using the following command with ***root*** privileges. 

```
# sysctl -w kernel.randomize_va_space=0
```

***Note***: The above command is only temporary and will reset back if the machine is power cycled. 

The following command is used to confirm that ASLR is indeed turned off (set to 0):

```
$ cat /proc/sys/kernel/randomize_va_space
```

### ExecShield

ExecShield is a security patch for the Linux kernel that aims to reduce the risk of worms or other automated remote attacks on Linux systems. Essentially what it does is disallowing execution of any code that is stored in the stack. This protection is implemented in Fedora Linux, but is not enabled by default on Ubuntu systems. The following command disables it:

```
# sysctl -w kernel.exec-shield=0
```

### Z Shell (zsh)

Many shell programs automatically drop their privileges when invoked. Even if you can “fool” a privileged Set-UID program to invoke a shell, the privileges may not necessarily be retained within the shell. This protection scheme is implemented in the bash shell (/bin/bash). For Ubuntu, /bin/sh is a symbolic link to /bin/bash. For the purpose of this project, the zsh shell was used instead of bash because it does not offer this protection. The zsh was first installed using the following command:

```
# apt-get install zsh
```

The zsh was then linked to /bin/sh using the following commands:

```
# cd /bin
# rm sh
# ln -s /bin/zsh /bin/sh
```

## Working With The Code

By now, your machine should have most system-based protections disabled. Now, let's take a look at the code. 

### exploit.c

This C source code is responsible for creating a text file (named "badfile") with the corresponding string that is used to overflow the buffer. It consists of the shellcode (in assembly form) which invokes a shell. Also, it consists of a return address to the malicious code (shellcode) which overwrites the original return address.

### stack.c

This C source code is the vulnerable program which reads in the "badfile" to an insufficiently sized buffer (12-bytes) without bounds checking. 

## Compile The Code

To observe the buffer overflow attack in action, let's start by compiling the necessary files and disabling the compiler-based protections. 

### StackGuard And NX Bit
GCC compiler implements this security mechanism to detect buffer overflows before execution of malicious code can occur. StackGuard works by adding a canary to the stack layout which holds a special guard value. A canary stores a dynamically calculated value where the function begins on the stack just before the stack return pointer. When a function is ready to return, the stack canary is popped off the stack, recomputed, and compared to the stored canary that was placed before the return address. If the canary has been overwritten, the program automatically exits with an error code indicating that the stack has been smashed. Disabling StackGuard required the “-fno-stack-protector-“ command when compiling C source code with GCC.

As well as StackGuard, there is also a NX (no-execute) bit technology that is supported in some operating systems. The NX bit may mark certain areas of memory as non-executable and prevents the processor from executing any code residing in these areas of memory. Disabling the NX bit requires the additional “-z execstack” command when compiling C source code with GCC. 

An example of compiling C source code with both StackGuard and the NX bit disabled is shown below:

```
# gcc -fno-stack-protector -z execstack -o stack stack.c
```

### Set-UID 

The user ID (UID) is a unique positive integer assigned by a Unix-like operating system to each user. A UID of 0 has a special role because it is always the root account. In the case of exploiting a vulnerable code to obtain a shell, it is noted that a non-root user is able to obtain root shell privileges by running a shell code as a setuid program. 

This is accomplished using the chmod command by setting the high-order octal digit to 4 to change the access privileges of the executable as shown below. 

```
# chmod 4755 stack
```

### Compile exploit.c

Compile the exploit code (exploit.c) normally. No compiler-level protections are needed to be disabled for this because all it does is generate the "badflie"

```
$ gcc -o exploit exploit.c
```

## Start The Exploit!

By now, everything should be ready to go. Start the buffer overflow attack using the following commands:

```
$ ./exploit
$ ./stack
# <<<< You should now have a root shell!
```

## Address Space Layout Randomization

An effective exploitation is able to bypass ASLR with enough iterations (randomized address space coincidently aligns with guess). 

Turn on ASLR using the following command:

```
# sysctl -w kernel.randomize_va_space=1
```

Run the bash script until a root shell is obtained. 

```
$ bash loop.sh
```

## References

This project is based on alephOne's "Smashing The Stack For Fun And Profit" paper found [here](http://cecs.wright.edu/people/faculty/tkprasad/courses/cs781/alephOne.html)


